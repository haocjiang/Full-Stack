--1.
--In my opinion, I would prefer using join to find the result since it takes faster processing time than subquery even though
--subquery enables more readability.

--2.
--CTE is a temporary named result that can offers the advantages of improved readability and ease in maintenance of complex queries.
--It's a substitue for a view when the general use of a view is not required. CTEs can be defined in user-defined routines.

--3.
--A table variable is a data type that can be used within a Transact-SQL batch, stored procedure, or function, and is created
--and defined similarly to a table, only with a strictly defined lifetime scope.

--4.
--a. Truncate reseeds identity values, whereas delete doesn't
--b. Truncate removes all records and doesn't fire triggers
--c. Truncate is faster compared to delete as it makes less use of the transaction log.
--d. Truncate is not possible when a table is referenced by a Foreign Key or tables are used in replication or with indexed views.

--5.
--An identity column is a column in a database table that is made up of values generated by the database. Its value are managed by the
--server and usually cannot be modified.

--6.
--delelte can use where to make filtering on what specific values are deleted, whereas truncate removes all records.

--Write queries for following scenarios

--1.
select distinct c.City
from customers c 
where c.city in (select e.city from Employees e)

--2.

--a.
select distinct c.City
from customers c
where not c.city in (select e.city from Employees e)

--b.
select distinct c.City
from customers c left join Employees e
on c.City = e.City

--3.
select p.ProductID, (select sum(od.Quantity) from [Order Details] od where od.productID = p.productID) as totalQuantity
from Products p
order by p.productID

--4.
select c.city, sum(od.Quantity) as QTY
from customers c left join orders o
on c.CustomerID = o.CustomerID left join [Order Details] od
on o.OrderID = od.OrderID
group by c.city
order by QTY desc

--5.

--a.
select c.City
from customers c
group by c.City
having count(c.CustomerID) > 2
union
select cu.City
from customers cu
group by cu.City
having count(cu.CustomerID) = 2

--b.
select distinct c.City
from customers c
where c.city in (select cu.City 
				from Customers cu 
				group by cu.City 
				having count(cu.CustomerID) >= 2)

--6.
select c.CustomerID
from Customers c inner join Orders o
on c.CustomerID = o.CustomerID inner join [Order Details] od
on o.OrderID = od.OrderID
group by c.CustomerID
having count(od.ProductID) >= 2

--7.
select distinct c.CustomerID
from Customers c inner join Orders o
on c.CustomerID = o.CustomerID
where c.City != o.ShipCity

select c.CustomerID
from customers c
where c.City not in (select o.shipcity from orders o inner join Customers c on o.CustomerID = c.CustomerID)

--8.
with OrderCTE
as
(
select oc.Shipcity, oc.ProductID, oc.averagePrice,
dense_rank() over(partition by oc.ProductID order by oc.totalQuantity) rnk
from (select top 5 od.ProductID, o.ShipCity, sum(od.Quantity) totalQuantity, avg(od.Unitprice) averagePrice
from orders o left join [Order Details] od
on o.OrderID = od.OrderID
group by o.ShipCity, od.ProductID
order by totalQuantity) oc
)
select * from OrderCTE
where rnk = 1

--9.

--a.
select e.City
from Employees e
where e.City not in(select c.city from Customers c 
					inner join Orders o on c.CustomerID = o.CustomerID)

--b.
select e.City
from employees e left join customers c
on e.City = c.City
where c.City is null

--10.
select * from
(select top 1 e.city, count(o.orderid) TotalOrder
from employees e inner join orders o
on e.EmployeeID = o.EmployeeID
group by e.City) e1
inner join
(select top 1 c.city, count(od.Quantity) TotalQuantity
from Customers c inner join Orders o
on c.CustomerID = o.CustomerID
inner join [Order Details] od
on o.OrderID = od.OrderID
group by c.City) c1
on e1.city = c1.city

--11.
--Using group by to filter out duplicate values and using delete to remove the values

--12.
with empHierarchyCTE
as
(
	select empid, mgrid, 1 lvl
	from employee where mgrid is null
	union all
	select e.empid, e.mgrid, ct.lvl+1
	from employee e inner join empHierarchyCTE ct
	on e.mgrid = ct.empid
)
select top 1 empid 
from empHierarchyCTE
order by empid desc
--13.


--14.
select deptname, empid, salary
from (select d.deptname, e.empid, e.salary,
rank() over(partition by e.deptid order by e.salary desc) rnk
from dept d, employee e
where d.deptid = e.deptid)
where rnk <= 3
order by deptname, rnk